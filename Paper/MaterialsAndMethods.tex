\section{Materials and Methods}
\subsection{MapReduce}
Collecting the tweets about the picked games starts with the MapReduce job that filters all tweets to the ones that match. To find matches a list of search words have been made for each game of the Top 20. These search words are the full name of the game (\code{Grand Theft Auto V}), possibly a short notation of the game (\code{GTA V}), and possibly a different number notation (\code{GTA 5}). This would still not match a tweet that contains \code{GTA5} or \code{gtav}, so the search words and tweets have been processed. The search words and tweet text have been set to lowercase, and all characters that are not in \code{a-z, 0-9} have been removed. This means that a tweet text \code{GTA 5 is a very cool game!} would be processed to \code{gta5isaverycoolgame}. Then a contains check is ran for every search word of every game, which results in a match at \code{gta5}. The filtering performed on the data ensures that all mentions of a game are caught, with exception of misspellings or very short notations. For example \emph{Call of Duty: Ghosts} could be called \emph{Ghosts}, but this word is too commonly used to add as search term, it would give too much false positives otherwise.

If the mapping phase of the MapReduce job finds a match, then it outputs the a line for the Reducer to process. The key of the line is build up like this: \code{<game>-<year>-<month>-<day>, 1.0}. So this mean it will output a text string as key, consisting of the game title, year, month and day. And output a \code{1.0} as double value. The reducer combines all lines that have the same key, adding their value together. This means that the result is a line for each day, that has the number of tweets of a certain game. With this data the number of tweets per game per day can be plotted.

\subsection{Website}
The results of the MapReduce task are processed by a Java program. This program collects all results from the different output files (one per machine in the cluster, 48 in this case) and groups them per game. The dates are parsed to a \emph{milliseconds since 1970} time stamp to be used with the graphing library. Any gaps in the data are filled with zero's, since a gap means there are zero tweets about that game on that day. After the reading, grouping and repairing of the data it is printed to a PHP file, this file contains one line that assigns a JavaScript object to a variable. The object that it assigns has game names as keys, and as value it has an array. This array contains one array per day, which then contains a time stamp and count. This is the format that HightCharts, the chosen JavaScript graphing library, uses.

The website itself displays some basic HTML and loads the HighCharts library. Then with PHP the file with the data is included in a JavaScript block. Now with JQuery the data is looped through and the HighCharts graphs are added to the DOM. 